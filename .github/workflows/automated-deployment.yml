name: Automated Deployment Pipeline

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests before deployment'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  NODE_VERSION: '18'
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  # Detect changes to determine what needs to be built/tested
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      services-changed: ${{ steps.changes.outputs.services }}
      frontend-changed: ${{ steps.changes.outputs.frontend }}
      api-gateway-changed: ${{ steps.changes.outputs.api-gateway }}
      infrastructure-changed: ${{ steps.changes.outputs.infrastructure }}
      should-deploy: ${{ steps.deploy-check.outputs.should-deploy }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2

    - name: Detect changes
      uses: dorny/paths-filter@v2
      id: changes
      with:
        filters: |
          services:
            - 'services/**'
            - 'automation/**'
            - 'ai-services/**'
          frontend:
            - 'frontend/**'
          api-gateway:
            - 'api-gateway/**'
          infrastructure:
            - 'infrastructure/**'
            - 'docker-compose*.yml'
            - '.env*.example'

    - name: Check if deployment should proceed
      id: deploy-check
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event_name }}" == "push" ]]; then
          if [[ "${{ steps.changes.outputs.services }}" == "true" ]] || \
             [[ "${{ steps.changes.outputs.frontend }}" == "true" ]] || \
             [[ "${{ steps.changes.outputs.api-gateway }}" == "true" ]] || \
             [[ "${{ steps.changes.outputs.infrastructure }}" == "true" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "should-deploy=false" >> $GITHUB_OUTPUT
        fi

  # Lint and format check
  lint-and-format:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run ESLint
      run: npm run lint

    - name: Check code formatting
      run: npm run format:check

  # Unit and integration tests
  test:
    runs-on: ubuntu-latest
    needs: [detect-changes]
    if: needs.detect-changes.outputs.should-deploy == 'true' && github.event.inputs.skip_tests != 'true'
    
    services:
      mongodb:
        image: mongo:6.0
        ports:
          - 27017:27017
        env:
          MONGO_INITDB_ROOT_USERNAME: admin
          MONGO_INITDB_ROOT_PASSWORD: password
          MONGO_INITDB_DATABASE: technovastore_test
        options: >-
          --health-cmd "mongosh --eval 'db.runCommand(\"ping\").ok'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      postgresql:
        image: postgres:15
        ports:
          - 5432:5432
        env:
          POSTGRES_DB: technovastore_test
          POSTGRES_USER: admin
          POSTGRES_PASSWORD: password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run unit tests
      run: npm run test:ci
      env:
        NODE_ENV: test
        MONGODB_URI: mongodb://REDACTED_DB_PASSWORD@localhost:27017/technovastore_test?authSource=admin
        POSTGRESQL_URI: postgresql://REDACTED_DB_PASSWORD@localhost:5432/technovastore_test
        REDIS_URI: redis://localhost:6379

    - name: Run integration tests
      run: npm run test:ci:integration
      env:
        NODE_ENV: test
        MONGODB_URI: mongodb://REDACTED_DB_PASSWORD@localhost:27017/technovastore_test?authSource=admin
        POSTGRESQL_URI: postgresql://REDACTED_DB_PASSWORD@localhost:5432/technovastore_test
        REDIS_URI: redis://localhost:6379

    - name: Generate test coverage
      run: npm run test:coverage
      env:
        NODE_ENV: test
        MONGODB_URI: mongodb://REDACTED_DB_PASSWORD@localhost:27017/technovastore_test?authSource=admin
        POSTGRESQL_URI: postgresql://REDACTED_DB_PASSWORD@localhost:5432/technovastore_test
        REDIS_URI: redis://localhost:6379

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

  # Build Docker images
  build:
    runs-on: ubuntu-latest
    needs: [detect-changes, lint-and-format]
    if: needs.detect-changes.outputs.should-deploy == 'true' && (success() || github.event.inputs.force_deploy == 'true')
    
    strategy:
      fail-fast: false
      matrix:
        include:
          - service: api-gateway
            context: ./api-gateway
            dockerfile: ./api-gateway/Dockerfile
            condition: ${{ needs.detect-changes.outputs.api-gateway-changed == 'true' || needs.detect-changes.outputs.infrastructure-changed == 'true' }}
          - service: product-service
            context: ./services/product
            dockerfile: ./services/product/Dockerfile
            condition: ${{ needs.detect-changes.outputs.services-changed == 'true' }}
          - service: order-service
            context: ./services/order
            dockerfile: ./services/order/Dockerfile
            condition: ${{ needs.detect-changes.outputs.services-changed == 'true' }}
          - service: user-service
            context: ./services/user
            dockerfile: ./services/user/Dockerfile
            condition: ${{ needs.detect-changes.outputs.services-changed == 'true' }}
          - service: payment-service
            context: ./services/payment
            dockerfile: ./services/payment/Dockerfile
            condition: ${{ needs.detect-changes.outputs.services-changed == 'true' }}
          - service: notification-service
            context: ./services/notification
            dockerfile: ./services/notification/Dockerfile
            condition: ${{ needs.detect-changes.outputs.services-changed == 'true' }}
          - service: ticket-service
            context: ./services/ticket
            dockerfile: ./services/ticket/Dockerfile
            condition: ${{ needs.detect-changes.outputs.services-changed == 'true' }}
          - service: sync-engine
            context: ./automation/sync-engine
            dockerfile: ./automation/sync-engine/Dockerfile
            condition: ${{ needs.detect-changes.outputs.services-changed == 'true' }}
          - service: auto-purchase
            context: ./automation/auto-purchase
            dockerfile: ./automation/auto-purchase/Dockerfile
            condition: ${{ needs.detect-changes.outputs.services-changed == 'true' }}
          - service: shipment-tracker
            context: ./automation/shipment-tracker
            dockerfile: ./automation/shipment-tracker/Dockerfile
            condition: ${{ needs.detect-changes.outputs.services-changed == 'true' }}
          - service: chatbot
            context: ./ai-services/chatbot
            dockerfile: ./ai-services/chatbot/Dockerfile
            condition: ${{ needs.detect-changes.outputs.services-changed == 'true' }}
          - service: recommender
            context: ./ai-services/recommender
            dockerfile: ./ai-services/recommender/Dockerfile
            condition: ${{ needs.detect-changes.outputs.services-changed == 'true' }}
          - service: frontend
            context: ./frontend
            dockerfile: ./frontend/Dockerfile
            condition: ${{ needs.detect-changes.outputs.frontend-changed == 'true' }}

    steps:
    - name: Skip if no changes
      if: matrix.condition == 'false'
      run: |
        echo "Skipping ${{ matrix.service }} - no relevant changes detected"
        exit 0

    - name: Checkout code
      if: matrix.condition != 'false'
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      if: matrix.condition != 'false'
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      if: matrix.condition != 'false'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      if: matrix.condition != 'false'
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.service }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=staging,enable=${{ github.ref == 'refs/heads/develop' }}
          type=raw,value=production,enable=${{ github.ref == 'refs/heads/main' }}

    - name: Build and push Docker image
      if: matrix.condition != 'false'
      uses: docker/build-push-action@v5
      with:
        context: ${{ matrix.context }}
        file: ${{ matrix.dockerfile }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha,scope=${{ matrix.service }}
        cache-to: type=gha,mode=max,scope=${{ matrix.service }}
        platforms: linux/amd64,linux/arm64
        build-args: |
          NODE_ENV=${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}

  # Security scanning
  security-scan:
    runs-on: ubuntu-latest
    needs: [build]
    if: always() && needs.build.result == 'success'
    
    strategy:
      fail-fast: false
      matrix:
        service: [api-gateway, product-service, order-service, user-service, payment-service, notification-service, ticket-service, sync-engine, auto-purchase, shipment-tracker, chatbot, recommender, frontend]

    steps:
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.service }}:${{ github.ref_name }}
        format: 'sarif'
        output: 'trivy-results-${{ matrix.service }}.sarif'
        severity: 'CRITICAL,HIGH'
        exit-code: '0'  # Don't fail the build on vulnerabilities

    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results-${{ matrix.service }}.sarif'

  # End-to-end tests
  e2e-tests:
    runs-on: ubuntu-latest
    needs: [build, test]
    if: |
      always() && 
      needs.build.result == 'success' && 
      (needs.test.result == 'success' || needs.test.result == 'skipped' || github.event.inputs.force_deploy == 'true') &&
      (github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Start services with Docker Compose
      run: |
        # Use staging compose file for E2E tests
        docker-compose -f docker-compose.staging.yml up -d
        sleep 120  # Wait longer for all services to be ready

    - name: Wait for services to be healthy
      run: |
        timeout 600 bash -c 'until curl -f http://localhost:3000/health; do echo "Waiting for API Gateway..."; sleep 10; done'
        timeout 600 bash -c 'until curl -f http://localhost:3011; do echo "Waiting for Frontend..."; sleep 10; done'

    - name: Run E2E tests
      run: npm run test:e2e
      env:
        BASE_URL: http://localhost:3011
        API_URL: http://localhost:3000

    - name: Upload E2E test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: e2e-test-results
        path: |
          frontend/test-results/
          frontend/playwright-report/

    - name: Stop services
      if: always()
      run: docker-compose -f docker-compose.staging.yml down

  # Deploy to staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build, security-scan, e2e-tests]
    if: |
      always() &&
      needs.build.result == 'success' &&
      (needs.e2e-tests.result == 'success' || needs.e2e-tests.result == 'skipped' || github.event.inputs.force_deploy == 'true') &&
      ((github.event_name == 'push' && github.ref == 'refs/heads/develop') ||
       (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging'))
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.STAGING_SSH_KEY }}

    - name: Add staging server to known hosts
      run: |
        ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

    - name: Deploy to staging
      uses: ./.github/actions/deploy
      with:
        environment: staging
        host: ${{ secrets.STAGING_HOST }}
        user: ${{ secrets.STAGING_USER }}
        compose-file: docker-compose.staging.yml
        env-vars: |
          MONGO_USERNAME=${{ secrets.STAGING_MONGO_USERNAME }}
          MONGO_PASSWORD=${{ secrets.STAGING_MONGO_PASSWORD }}
          POSTGRES_USERNAME=${{ secrets.STAGING_POSTGRES_USERNAME }}
          POSTGRES_PASSWORD=${{ secrets.STAGING_POSTGRES_PASSWORD }}
          REDIS_PASSWORD=${{ secrets.STAGING_REDIS_PASSWORD }}
          JWT_SECRET=${{ secrets.STAGING_JWT_SECRET }}
          SMTP_HOST=${{ secrets.STAGING_SMTP_HOST }}
          SMTP_PORT=${{ secrets.STAGING_SMTP_PORT }}
          SMTP_USER=${{ secrets.STAGING_SMTP_USER }}
          SMTP_PASS=${{ secrets.STAGING_SMTP_PASS }}
          NEXT_PUBLIC_API_URL=http://${{ secrets.STAGING_HOST }}:3000
          FRONTEND_URL=http://${{ secrets.STAGING_HOST }}:3011

    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          STATUS="âœ… SUCCESS"
          COLOR="good"
        else
          STATUS="âŒ FAILED"
          COLOR="danger"
        fi
        
        curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"$COLOR\",
              \"title\": \"TechNovaStore Staging Deployment\",
              \"fields\": [
                {\"title\": \"Status\", \"value\": \"$STATUS\", \"short\": true},
                {\"title\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"short\": true},
                {\"title\": \"Commit\", \"value\": \"${{ github.sha }}\", \"short\": true},
                {\"title\": \"Environment\", \"value\": \"Staging\", \"short\": true},
                {\"title\": \"URL\", \"value\": \"http://${{ secrets.STAGING_HOST }}:3011\", \"short\": true}
              ],
              \"footer\": \"GitHub Actions\",
              \"ts\": $(date +%s)
            }]
          }" \
          ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"

  # Deploy to production
  deploy-production:
    runs-on: ubuntu-latest
    needs: [build, security-scan]
    if: |
      always() &&
      needs.build.result == 'success' &&
      ((github.event_name == 'push' && github.ref == 'refs/heads/main') ||
       (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'))
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.PRODUCTION_SSH_KEY }}

    - name: Add production server to known hosts
      run: |
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

    - name: Deploy to production
      uses: ./.github/actions/deploy
      with:
        environment: production
        host: ${{ secrets.PRODUCTION_HOST }}
        user: ${{ secrets.PRODUCTION_USER }}
        compose-file: docker-compose.prod.yml
        backup: true
        env-vars: |
          MONGO_ROOT_USERNAME=${{ secrets.PRODUCTION_MONGO_USERNAME }}
          MONGO_ROOT_PASSWORD=${{ secrets.PRODUCTION_MONGO_PASSWORD }}
          POSTGRES_USER=${{ secrets.PRODUCTION_POSTGRES_USERNAME }}
          POSTGRES_PASSWORD=${{ secrets.PRODUCTION_POSTGRES_PASSWORD }}
          REDIS_PASSWORD=${{ secrets.PRODUCTION_REDIS_PASSWORD }}
          JWT_SECRET=${{ secrets.PRODUCTION_JWT_SECRET }}
          SMTP_HOST=${{ secrets.PRODUCTION_SMTP_HOST }}
          SMTP_PORT=${{ secrets.PRODUCTION_SMTP_PORT }}
          SMTP_USER=${{ secrets.PRODUCTION_SMTP_USER }}
          SMTP_PASS=${{ secrets.PRODUCTION_SMTP_PASS }}

    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          STATUS="ðŸš€ SUCCESS"
          COLOR="good"
        else
          STATUS="ðŸš¨ FAILED"
          COLOR="danger"
        fi
        
        curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"$COLOR\",
              \"title\": \"TechNovaStore Production Deployment\",
              \"fields\": [
                {\"title\": \"Status\", \"value\": \"$STATUS\", \"short\": true},
                {\"title\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"short\": true},
                {\"title\": \"Commit\", \"value\": \"${{ github.sha }}\", \"short\": true},
                {\"title\": \"Environment\", \"value\": \"Production\", \"short\": true}
              ],
              \"footer\": \"GitHub Actions\",
              \"ts\": $(date +%s)
            }]
          }" \
          ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"